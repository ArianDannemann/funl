"""
> Interprets funl models

This module can interpret funl textx models produced by the parser, it is the
heart of the funl programming language.
"""

from .utils import logger
from .functions import f_print
from .functions import f_int


# FUNCTION_MAP contains references to each inbuilt funl functions handler functions
# See functions/ fo all inbuilts
FUNCTION_MAP = {
    "print": f_print.handle,
    "int": f_int.handle
}


def interpret_model(model: any) -> None:
    """
    Runs funl language logic on a textx model. Loops through all statements of
    a model (application written in funl) and redirects the statements data to
    the two processing functions:
    1. Native function calls, i.e. 'print'
    2. User defined function definitions and calls
    Continues to the next statement when one of the processors returns True on
    the statement, meaning it was "consumend" by the processor.

    model: textx.Model  The model to interpret, can be generated by calling
                        parser on a file
    """

    for statement in model.statement:
        logger.log_debug("Interpreter", f"interpret_model: {statement}")

        if _process_function_call(statement):
            continue
    
        logger.log_error("Interpreter", f"Unknown token: {statement.name}")


def _process_function_call(statement: any) -> bool:
    """
    Processes a native function call. Native calls are all calls referencing one
    of the inbuilt funl functions, i.e. 'print', 'int', ...
    Native functions are defined in their own .py file in functions/ and
    referenced by adding them to the FUNCTION_MAP which also stores their name
    for easy access.

    statement: textx.Statement  The statement to process

    bool                        True if statement is a native function call and
                                could be handled, False otherwise
    """

    if statement.__class__.__name__ != "FunctionCall":
        return False

    try:
        native_call = FUNCTION_MAP[statement.name]
    except KeyError:
        return False

    logger.log_debug("Interpreter", f"_process_native_call: {statement.name}")

    native_call(statement.params)

    return True